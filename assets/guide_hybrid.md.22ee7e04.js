import{_ as e,c as i,o as a,O as r}from"./chunks/framework.06c7c283.js";const t="/mobile/guide/9.png",m=JSON.parse('{"title":"Hybrid","description":"","frontmatter":{},"headers":[],"relativePath":"guide/hybrid.md","lastUpdated":1679824266000}'),o={name:"guide/hybrid.md"},d=r('<h1 id="hybrid" tabindex="-1">Hybrid <a class="header-anchor" href="#hybrid" aria-label="Permalink to &quot;Hybrid&quot;">​</a></h1><p>hybrid即<code>混合</code>，即前端和客户端的混合开发，需要前端开发人员和客户端开发人员配合完成，某些环节也可能涉及到server端，在更新和升级的时候就涉及到server端。</p><p>hybrid它的优势是可以快速迭代更新，无需app审核。app的更新需要Android或iOS AppStore应用商店审核的，国内Android像华为、oppo、小米审核较快，iOS审核较慢。所以使用原生开发想要快速上线是不可能的，但是hybrid就能解决这个问题。</p><p>其次体验也十分流畅，不仔细计较的话和NA的体验基本类似。同时也减少开发和沟通成本，双端公用一套代码，因为页面采用前端来开发，可以在Android和iOS的webview上运行。</p><h2 id="webview" tabindex="-1">webview <a class="header-anchor" href="#webview" aria-label="Permalink to &quot;webview&quot;">​</a></h2><p>webview是app中的一个组件，在app中可以有webview也可以没有，它主要用于加载H5页面，可以是远程的页面也可以使本地的页面，即一个小型的浏览器内核。</p><p>最早的实践就是通过 WebView 双端运行 Web 代码。事实上，虽然 iOS 和 Android 系统难以统一，但是它们都对 Web 技术开放，于是有的人开玩笑：“不管是 Mac、Windows、Linux、iOS、Android 还是其他平台，只要给一个浏览器，连‘月球’上它都能跑。”因此，Hybrid 方案算是最古老，但也是最成熟、应用最为广泛的技术。</p><h2 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h2><ul><li>NA：体验要求极致，变化不频繁，例如头条的首页</li><li>hybrid：体验要求高，变化频繁，例如头条的新闻详情页</li><li>h5：体验无要求，不常用，例如举报、反馈等页面</li></ul><h2 id="实现流程" tabindex="-1">实现流程 <a class="header-anchor" href="#实现流程" aria-label="Permalink to &quot;实现流程&quot;">​</a></h2><ol><li>前端做好静态页面(html、js、css)，将文件交给客户端</li><li>客户端拿到前端静态页面，以文件形式存储在app中</li><li>客户端在一个webview中使用file协议加载静态页面</li></ol><h2 id="jsbridge" tabindex="-1">JSBridge <a class="header-anchor" href="#jsbridge" aria-label="Permalink to &quot;JSBridge&quot;">​</a></h2><p>在 iOS 和 Android 系统上运行 JavaScript 并不是一件难事儿，但是对于一个真正意义上的跨平台应用来说，还需要做到H5（即 WebView 容器）和原生平台的交互，于是 JSBridge 技术就诞生了。</p><p><img src="'+t+'" alt=""></p><p>JS和客户端通讯的基本流程就是JS访问客户端能力，传递参数和回调函数，然后客户端通过回调函数返回内容。</p><p>JSBridge 原理很简单，我们知道，在原生平台中，JavaScript 代码是运行在一个单独的 JS Context 中（比如 WebView 的 WebKit 引擎、JavaSriptCore 等），这个独立的上下文和原生能力的交互过程是双向的，我们可以从两个方面简要分析。</p><ol><li>JavaScript 调用 Native，方法有：</li></ol><ul><li>注入 APIs；</li><li>拦截 URL Scheme。</li></ul><ol start="2"><li>Native 调用 JavaScript。</li></ol><p>前端调用原生能力主要有两种方式，注入 APIs 其实就是原生平台通过 WebView 提供的接口，向 JavaScript Context 中（一般使用 Window 对象），注入相关方案和数据；另一种拦截 URL Scheme 就更加简单了，前端通过发送定义好的 URL Scheme 请求，并将相关数据放在请求体中，该请求被原生平台拦截后，由原生平台做出响应。</p><p>Native 调用 JavaScript，实现起来也很简单。因为 Native 实际上是 WebView 的宿主，因此 Native 具有更大权限，故而原生平台可以通过 WebView APIs 直接执行 JavaScript 代码。</p><h3 id="schema协议" tabindex="-1">schema协议 <a class="header-anchor" href="#schema协议" aria-label="Permalink to &quot;schema协议&quot;">​</a></h3><p>前端和客户端通信传递参数和callback的这种方式，其本质和前端和后端发送http请求类似，前后端通信依赖于http协议，那么前端和客户端通信自然而然也会有一种协议来约定，这种协议称为schema协议。</p>',23),l=[d];function p(h,c,s,n,b,S){return a(),i("div",null,l)}const u=e(o,[["render",p]]);export{m as __pageData,u as default};
